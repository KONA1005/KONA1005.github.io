---
title: " [JAVA] 헷갈리는 개념 + 배열 "
date: 2022-06-23-01
categories: JAVA
---

# 헷갈리는 개념

## 클래스는 설계도 !


## 명사
- 변수명 / 객체
  

## 동사
- 함수

### 설계시점에 자기자신 호출하지 말기
- 아주 한정된 시점에 재귀호출할때만 쓴다.


```java
public calss 요리사{
    경력
    전공
    현직장

    public void 요리하다(무엇을){
        잡채, 떡볶이, 짜장면 3개를 요리할 수 있다고 해서
        이 요리하다 함수안에 잡채, 떡볶이, 짜장면이라는 정보를 넣으면 안된다.
        무엇을 주입받아서 그놈을 요리하게끔 해야한다!!!!
    };
}

요리사 백종원 = new 요리사();
```

## 배열 Array
> 동일한 자료형'의 '순차적'인 자료구조
> 같은 데이터타입의 연관된 여러개의 데이터를 하나의 변수에 담아서 쉽게 관리할수 있도록 해주는 자료구조중 하나
- 인덱스는 0부터 시작한다.
- 장점 : 인덱스를 활용하여 빠른 참조가능
- 단점 : 크기가 선언시의 크기에서 바꿀수 없다.
- 생성법 : 자료형[] 배열이름 = {값1, 값2, 값3...};
        자료형[] 배열이름 = new 자료형[크기];
- 사용법 : 배열이름[인덱스];
배열의 모든요소 **출력** : Arrays.toString(배열명) 쓰거나 아래처럼 반복문
```Java 
  String[] memebers = {"최진혁", "최유빈", "한이람"};
  for (String e : members){ // 향상된 for문
    System.out.println(e +"이 상담을 받았습니다.");  //하나하나의 원소에 대해서 무슨처리를 할것인지
  }

```

```Java
//크기 할당 & 초기화 없이 배열 참조변수만 선언
int[] arr;
int arr[];

// 선언과 동시에 배열 크기 할당
int[] arr = new int[5];
String[] arr = new String[5];

// 기존 배열의 참조 변수에 초기화 할당하기
int[] arr; arr = new int[5]; //5의 크기를 가지고 초기값 0으로 채워진 배열 생성

// 선언과 동시에 배열의 크기 지정 및 값 초기화
int[] arr = {1,2,3,4,5};
int[] arr = new int[] {1,3,5,2,4};
int[] odds = {1,3,5,7,9};
String[] weeks = {"월","화","수","목","금","토","일"};

	intArr3 = {1,2,3,4,5};	//C언어 형식. 자바에서는 문법에러
  //Array constants can only be used in initializers
  //배열상수는 초기화에만 사용할 수 있습니다.
  intArr3 = new int[]{1,2,3,4,5};	//Java형식

// 2차원 배열 선언
int[][] arr = new int[4][3]; //3의 크기의 배열을 4개 가질 수 있는 2차원 배열 할당
int[][] arr9 = { {2, 5, 3}, {4, 4, 1}, {1, 7, 3}, {3, 4, 5}};

```

데이터는 중괄호로 감싸고 각값은 쉼표로 구분. 데이터의 모임이라는 표시를 하는 []에 저장.
  데이터타입[] 배열명 = {해당데이터타입의 데이터1, 해당데이터타입의 데이터2, 해당데이터타입의 데이터3...}
설명 :
  변수의 진정한 의미 :  "반장 이리 와봐" 라고 하면 선생님은 그반의 반장이 누군지 몰라도됨. 반장이 바뀌더라도 반장이 호출됨.  하드코딩 방지(유연성 증가)
  배열의 진정한 의미 : 순서가 원소들이 어느 집합에 소속됨.  "5번 p.5페이지 읽어"  5번이 누군지 몰라도됨.
                      1번 상담끝, 다음 2번, 다음 3... 학생의 총원과 상담한인원이 같으면 상담 끝.
핵심 :
  - **인덱스(index)** : 색인 : 내용이 어디에 적혀있는지 알려주는 역할. 주소를 나타냄. 0부터 시작.
  - 정의할때 반드시 배열에 몇개의 값을 담을수 있는지 꼭 지정해야 한다. 즉 **배열의 길이는 최초 선언한 값으로 고정**됨. 배열의 최대단점

  - 배열이 갖고있지 않은 인덱스에 접근하면 OutOfBoundsException발생. 파이썬이나 자바스크립트 같은 고급언어에서는 크기가 자연적으로 변경되는데 자바는 왜 이렇게 융통성이 없게 만들어놨을까?
  현실에서 50가구가 살 아파트를 지었는데, 이미 짓고나면 51가구가 들어올수있나? 없다.
  그럼 50가구를 살 것이지만 넉넉잡아서 100가구가 살도록 만들면 안되나?  부동산 가격이 매우 비싸기 때문에 현실적으로 불가능.
  바로 컴퓨터 세상에서도 가장 비싼자원인 메모리에 공간을 할당받기 때문에 딱맞게 쓸만큼만 할당해서 효율적으로 사용해야 한다.**메모리에 연속적으로 할당됨.**
  그런데 자원의 효율적인 활용을 위해서 인간이 너무 불편하다. 그 불편을 극복한것이 **컬렉션(Collection)**
  - 자바의 배열은 처음설정된 크기가 고정적이 되어 변동될 수 없다.
  이런 치명적인 단점이 있기 때문에 실무에서 배열 그 자체로는 잘 쓰이지 않고,
  다른 자료구조의 부품으로써 주로 쓰인다.
  - length메서드는 현재 배열에 담겨있는 원소의 갯수가 아니라 배열에 담을수 있는 원소의 갯수. 즉 고정된 크기를 반환한다. 고급언어에 속하는 좀더 쉬운언어에서는 보통 담긴 갯수가 리턴된다.
  - 향상된 for문을 for-each문이라고 한다. while문에서 반복해서 사용하는 패턴을 따로 문법적으로 승화한것. 배열과 반복문은 매우 밀접한 관계
    이 문법이 없다면 배열의 담긴 값을 하나씩 꺼내서 처리하는것을 위해서 배열의 크기를 알아야하고, 반복을 위한 기본값을 세팅해야하고, 그것을 1씩 증가시켜야 하는 노가다 작업의 불편함이 있다.


### Arrays 객체
  - 값으로 인덱스 빼오기 :  Arrays.asList(배열명).indexOf(값)
  - 정렬 : Arrays.sort(배열명);
